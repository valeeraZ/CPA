#include <stdlib.h>
#include <stdio.h>
#include <set>
#include <list>
#include <time.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>
#include <map>
#include <math.h>

//the node on edge connected to the start node of array
struct EdgeNode
{
    long adjVex;
    //EdgeNode *next;
    EdgeNode(long data)
    {
        adjVex = data;
        //next = NULL;
    }
};
//the start node of array
struct VertexNode
{
    long data;
    std::list<EdgeNode> first;
};

struct Edge
{
    unsigned long s;
    unsigned long t;
};

unsigned long numberNodes;
unsigned long numberEdges;
std::set<long> nodes;
std::list<Edge> edges;
//key for the symbol of node, value for the position(increasing order) of node
std::unordered_map<long, long> mapNodes;
//the list of "start nodes"
VertexNode *AL_Node;
//furhest node calculated by BFS
unsigned long furthestNode;
//max distance from start node to furthese node calculated by
unsigned long maxDistance = 0;

void readEdgeList(FILE *file)
{
    unsigned long s, t;
    Edge edge;
    while (fscanf(file, "%lu %lu", &(edge.s), &(edge.t)) == 2)
    {
        nodes.insert(edge.s);
        nodes.insert(edge.t);
        edges.push_back(edge);
    }
    numberEdges = edges.size();
    numberNodes = nodes.size();
    fclose(file);
}

void makeAjdArray()
{
    AL_Node = new VertexNode[numberNodes];
    std::set<long>::iterator it = nodes.begin();
    for (int i = 0; i < numberNodes, it != nodes.end(); i++, it++)
    {
        AL_Node[i].data = *it;
        mapNodes[*it] = i;
    }

    for (Edge edge : edges)
    {
        long position_s = mapNodes[edge.s];
        long position_t = mapNodes[edge.t];

        AL_Node[position_s].first.push_back(EdgeNode(edge.t));

        //another direction also
        AL_Node[position_t].first.push_back(EdgeNode(edge.s));
    }
}

void freeAdjArray()
{
    AL_Node = NULL;
    delete AL_Node;
}

std::unordered_map<unsigned long, unsigned long> bfs(unsigned long start)
{
    maxDistance = 0;
    time_t t3,t4;
    t3 = time(NULL);
    std::queue<unsigned long> queue;
    //pair<node, distance>: distance of each node from start
    std::unordered_map<unsigned long, unsigned long> distance;
    queue.push(start);
    distance.insert(std::pair<unsigned long, unsigned long>(start, 0));
    int i = 0;
    while (!queue.empty())
    {
        unsigned long top = queue.front();
        queue.pop();
        //std::cout << "The NODE " << top << " Distance from START " << start << " is " << distance[top] << std::endl;
        long position = mapNodes.at(top);
        int d = distance[top] + 1;
        for (EdgeNode node : AL_Node[position].first)
        {
            //not visited
            if (distance.find(node.adjVex) == distance.end())
            {
                if(maxDistance < d){
                    maxDistance = d;
                    furthestNode = node.adjVex;
                }
                distance.insert(std::pair<long, long>(node.adjVex, d));
                queue.push(node.adjVex);
            }
        }
    }
    t4 = time(NULL);
    printf("BFS time = %ldh%ldm%lds\n", (t4 - t3) / 3600, ((t4 - t3) % 3600) / 60, ((t4 - t3) % 60));
    return distance;
}

/**
 * return a map<son, father> of tree generated by bfs
 * N nodes => N entry
 */
std::map<unsigned long, unsigned long> bfsTree(unsigned long start)
{
    std::queue<unsigned long> queue;
    std::map<unsigned long, unsigned long> tree;
    queue.push(start);
    int i = 0;
    while (!queue.empty())
    {
        unsigned long top = queue.front();
        queue.pop();
        long position = mapNodes[top];
        for (EdgeNode node : AL_Node[position].first)
        {
            if (tree.find(node.adjVex) == tree.end())
            {
                if(! (tree.find(AL_Node[position].data) != tree.end() && tree[AL_Node[position].data] == node.adjVex)){
                    tree.insert(std::pair<long, long>(node.adjVex, AL_Node[position].data));
                    queue.push(node.adjVex);
                }   
            }
        }
    }
    return tree;
}

struct cmp
{
    bool operator()(const std::pair<long, long> &P1, const std::pair<long, long> &P2)
    {
        return P1.second > P2.second;
    }
};

void diameter()
{
    unsigned long N1 = *(nodes.begin());
    bfs(N1);
    //find the furthest node A: sort the distance map by value, in order decreasing
    //std::vector<std::pair<unsigned long, unsigned long>> vectorDistance(mapDistance.begin(), mapDistance.end());
    //std::sort(vectorDistance.begin(), vectorDistance.end(), cmp());
    //the furthest node
    //unsigned long furthestNode = vectorDistance.begin()->first;
    //do bfs again, from the furthest node A
    //mapDistance = bfs(furthestNode);
    unsigned long N2 = furthestNode;
    bfs(N2);
    //sort
    //vectorDistance.assign(mapDistance.begin(), mapDistance.end());
    //std::sort(vectorDistance.begin(), vectorDistance.end(), cmp());
    //the lower bound diameter
    //unsigned long node = vectorDistance.begin()->first;
    //unsigned long lower_diameter = vectorDistance.begin()->second;
    unsigned long N3 = furthestNode;
    unsigned long lower_diameter = maxDistance;
    std::cout << "The lower bound diameter of graph: " << lower_diameter << std::endl;

    //upper bound: from the destination, go up d/2 times to the mid point in the lower bound path
    std::map<unsigned long, unsigned long> tree = bfsTree(N2);
    for(int i = 0; i < lower_diameter / 2 ; i++){
        //node -> father of itself
        //std::cout << destination << " ";
        N3 = tree.at(N3);
    }
    //std::cout << tree.at(destination) << std::endl;
    //std::cout<< "Mid node: " << destination << std::endl;
    //do bfs, from the mid node
    //std::unordered_map<unsigned long, unsigned long> mapDistance = bfs(destination);
    bfs(N3);
    //sort
    //std::vector<std::pair<unsigned long, unsigned long>> vectorDistance(mapDistance.begin(), mapDistance.end());
    //std::sort(vectorDistance.begin(), vectorDistance.end(), cmp());
    //the upper bound diameter
    unsigned long upper_diameter = maxDistance * 2;
    std::cout << "The upper bound diameter of graph: " << upper_diameter << std::endl;
}

int main(int argc, char **argv)
{
    if (argc < 2)
    {
        perror("usage: <file_name> optional: <header_lines_to_ignore>");
        exit(1);
    }

    time_t t1, t2;
    t1 = time(NULL);
    printf("Reading graph from file %s\n", argv[1]);
    FILE *file = fopen(argv[1], "r");
    //ignore the first N lines of file (information about graph)
    if (argc == 3)
    {
        int headerLines = atoi(argv[2]);
        for (int i = 0; i < headerLines; i++)
            fscanf(file, "%*[^\n]%*c");
    }

    readEdgeList(file);

    printf("Number of edges: %lu\n", numberEdges);
    printf("Number of nodes: %lu\n", numberNodes);

    makeAjdArray();
    diameter();
    freeAdjArray();
    t2 = time(NULL);

    printf("- Overall time = %ldh%ldm%lds\n", (t2 - t1) / 3600, ((t2 - t1) % 3600) / 60, ((t2 - t1) % 60));
}
